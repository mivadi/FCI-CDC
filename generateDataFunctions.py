import numpy as np
from kernelFunctions import kernel


def function(X, linear=False, strength=None, sign=None, noise_type=None):
    """
    Returns f(X) where f is randomly chosen to be linear, sine, cube, power or division.
        :param X: numpy array with dimension (N,1)
        :param linear: boolean indicating if relationship has to be linear
        :param strength: strength of cause: None or string ('none', 'weak', 'neutral', 'strong', 'extreme') 
        :param sign: sign of cause
        :param noise_type: if the noise type is given and equals Gaussian, then we will avoid a linear relationship
    """

    # decide if we need to avoid a linear relationship
    if noise_type=='Gaussian':
        all_functions = [1,2,3,4]
    else:
        all_functions = [0,1,2,3,4]

    # choose function randomly
    rand_num = np.random.choice(all_functions)

    # compute coeffient
    c = coefficient(strength, sign)

    # calculate f(X)
    if rand_num == 0 or linear:
        # linear
        out = c * X
    elif rand_num == 1:
        # sine
        out = c * np.sin(X)
    elif rand_num == 2:
        # cube
        out = c * X ** 3
    elif rand_num == 3:
        # power
        out = 2 **(c * X)
    elif rand_num == 4:
        # division
        out = c / (1+X**2)

    return out


def coefficient(strength=None, sign=None, epsilon = 0.01):
    """
    Returns the coefficient that 
        :param strength: strength of cause: None or string ('none', 'weak', 'neutral', 'strong', 'extreme') 
        :param sign: sign of cause
        :param epsilon: small value close to zero
    """

    # choose interval depending on strength to generate the coefficient
    if strength == 'none':
        a, b = 0, epsilon
    elif strength == 'weak':
        a, b = epsilon, .4
    elif strength == 'strong':
        a, b = 2.6, 3
    elif strength == 'extreme':
        a, b = 100, 200
    else: # neutral
        a, b = .5, 1.5

    # choose sign either positive or random
    if sign == '+':
        return np.random.uniform(a,b)
    else:
        return np.random.choice([-1, 1]) * np.random.uniform(a,b)


def noise(noise_type, N, epsilon = 0.01, track=False):
    """
    Returns heteroscedastic Gaussian noise or Uniform noise.
        :param noise_type: noise type ('Gaussian' or 'Uniform')
        :param N: sample size
        :param epsilon: small value close to zero
        :param track: boolean to indicate if we need to track the noise type to avoid linear Gaussian relationships
    """

    # if noise type is None: choose the type of noise randomly
    if noise_type is None:
        noise_type = np.random.choice(['Uniform', 'Gaussian'])

    if noise_type == 'Gaussian':
        # heteroscedastic Gaussian noise
        x = np.arange(1,N+1) / N
        std = np.random.uniform(epsilon, 2, N) * x
        noise_val = np.random.normal(scale=std)[:,None]
    else:
        # default is uniform between -1 and 1 (not too close to 0)
        noise_val = np.random.choice([-1, 1], size=(N,1)) * np.random.uniform(epsilon, 1, (N, 1))

    if track:
        # track the noise type to avoid linear Gaussian relationships
        return noise_val, noise_type
    else:
        return noise_val


def normalizeData(x):
    """
    Returns normalized data.
        :param x: numpy array with dimension (N,1)
    """

    return ( x - np.mean(x) ) / np.std(x)


def GaussianProcessEffect(N, cause, noise_type=None, additive_noise=True, kernel_width=None, linear_coef=None):
    """
    Returns data of the effect variable generated by a Gaussian Process (see Pattern Recognition and Machine Learning - Bishop (page 307)).
        :param N: sample size
        :param cause: tuple of numpy arrays of shape (N,1) that are the causes
        :param noise_type: noise type ('Gaussian' or 'Uniform')
        :param additive_noise: boolean indicating if there must be additive noise
        :param kernel_width: kernel width
        :param linear_coef: linear coefficient
    """

    if len(cause)>0:

        if not additive_noise:
            # create a matrix containing all input causes
            # and the noise if it is not additive
            cause = cause + (noise(noise_type, N),)

        # (re)define kernel width
        if kernel_width is None or kernel_width<=0:
            kernel_width = np.random.uniform(1, 3)

        # define linear coefficient
        if linear_coef is None:
            linear_coef = np.random.uniform(0, 3)

        # compute covariance matrix
        cov = kernel(np.hstack(cause), N, kernel_width=kernel_width, linear_coef=linear_coef)

        # define mean
        mean = np.zeros(N)

        # compute effect
        effect = np.random.multivariate_normal(mean, cov)[:,None]

        # add noise if noise is additve
        if additive_noise:
            # probabilistic effect and additive noise
            effect =  effect + noise(noise_type, N)
    else:

        # if there are no causes, then compute noise randomly
        effect = noise(noise_type, N)

    return effect


